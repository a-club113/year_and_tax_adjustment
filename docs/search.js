window.pdocSearch = (function () {
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function () { function e(e) { if (null === e || "object" != typeof e) return e; var t = e.constructor(); for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } var t = function (e) { var n = new t.Index; return n.pipeline.add(t.trimmer, t.stopWordFilter, t.stemmer), e && e.call(n, n), n }; t.version = "0.9.5", lunr = t, t.utils = {}, t.utils.warn = function (e) { return function (t) { e.console && console.warn && console.warn(t) } }(this), t.utils.toString = function (e) { return void 0 === e || null === e ? "" : e.toString() }, t.EventEmitter = function () { this.events = {} }, t.EventEmitter.prototype.addListener = function () { var e = Array.prototype.slice.call(arguments), t = e.pop(), n = e; if ("function" != typeof t) throw new TypeError("last argument must be a function"); n.forEach(function (e) { this.hasHandler(e) || (this.events[e] = []), this.events[e].push(t) }, this) }, t.EventEmitter.prototype.removeListener = function (e, t) { if (this.hasHandler(e)) { var n = this.events[e].indexOf(t); -1 !== n && (this.events[e].splice(n, 1), 0 == this.events[e].length && delete this.events[e]) } }, t.EventEmitter.prototype.emit = function (e) { if (this.hasHandler(e)) { var t = Array.prototype.slice.call(arguments, 1); this.events[e].forEach(function (e) { e.apply(void 0, t) }, this) } }, t.EventEmitter.prototype.hasHandler = function (e) { return e in this.events }, t.tokenizer = function (e) { if (!arguments.length || null === e || void 0 === e) return []; if (Array.isArray(e)) { var n = e.filter(function (e) { return null === e || void 0 === e ? !1 : !0 }); n = n.map(function (e) { return t.utils.toString(e).toLowerCase() }); var i = []; return n.forEach(function (e) { var n = e.split(t.tokenizer.seperator); i = i.concat(n) }, this), i } return e.toString().trim().toLowerCase().split(t.tokenizer.seperator) }, t.tokenizer.defaultSeperator = /[\s\-]+/, t.tokenizer.seperator = t.tokenizer.defaultSeperator, t.tokenizer.setSeperator = function (e) { null !== e && void 0 !== e && "object" == typeof e && (t.tokenizer.seperator = e) }, t.tokenizer.resetSeperator = function () { t.tokenizer.seperator = t.tokenizer.defaultSeperator }, t.tokenizer.getSeperator = function () { return t.tokenizer.seperator }, t.Pipeline = function () { this._queue = [] }, t.Pipeline.registeredFunctions = {}, t.Pipeline.registerFunction = function (e, n) { n in t.Pipeline.registeredFunctions && t.utils.warn("Overwriting existing registered function: " + n), e.label = n, t.Pipeline.registeredFunctions[n] = e }, t.Pipeline.getRegisteredFunction = function (e) { return e in t.Pipeline.registeredFunctions != !0 ? null : t.Pipeline.registeredFunctions[e] }, t.Pipeline.warnIfFunctionNotRegistered = function (e) { var n = e.label && e.label in this.registeredFunctions; n || t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n", e) }, t.Pipeline.load = function (e) { var n = new t.Pipeline; return e.forEach(function (e) { var i = t.Pipeline.getRegisteredFunction(e); if (!i) throw new Error("Cannot load un-registered function: " + e); n.add(i) }), n }, t.Pipeline.prototype.add = function () { var e = Array.prototype.slice.call(arguments); e.forEach(function (e) { t.Pipeline.warnIfFunctionNotRegistered(e), this._queue.push(e) }, this) }, t.Pipeline.prototype.after = function (e, n) { t.Pipeline.warnIfFunctionNotRegistered(n); var i = this._queue.indexOf(e); if (-1 === i) throw new Error("Cannot find existingFn"); this._queue.splice(i + 1, 0, n) }, t.Pipeline.prototype.before = function (e, n) { t.Pipeline.warnIfFunctionNotRegistered(n); var i = this._queue.indexOf(e); if (-1 === i) throw new Error("Cannot find existingFn"); this._queue.splice(i, 0, n) }, t.Pipeline.prototype.remove = function (e) { var t = this._queue.indexOf(e); -1 !== t && this._queue.splice(t, 1) }, t.Pipeline.prototype.run = function (e) { for (var t = [], n = e.length, i = this._queue.length, o = 0; n > o; o++) { for (var r = e[o], s = 0; i > s && (r = this._queue[s](r, o, e), void 0 !== r && null !== r); s++); void 0 !== r && null !== r && t.push(r) } return t }, t.Pipeline.prototype.reset = function () { this._queue = [] }, t.Pipeline.prototype.get = function () { return this._queue }, t.Pipeline.prototype.toJSON = function () { return this._queue.map(function (e) { return t.Pipeline.warnIfFunctionNotRegistered(e), e.label }) }, t.Index = function () { this._fields = [], this._ref = "id", this.pipeline = new t.Pipeline, this.documentStore = new t.DocumentStore, this.index = {}, this.eventEmitter = new t.EventEmitter, this._idfCache = {}, this.on("add", "remove", "update", function () { this._idfCache = {} }.bind(this)) }, t.Index.prototype.on = function () { var e = Array.prototype.slice.call(arguments); return this.eventEmitter.addListener.apply(this.eventEmitter, e) }, t.Index.prototype.off = function (e, t) { return this.eventEmitter.removeListener(e, t) }, t.Index.load = function (e) { e.version !== t.version && t.utils.warn("version mismatch: current " + t.version + " importing " + e.version); var n = new this; n._fields = e.fields, n._ref = e.ref, n.documentStore = t.DocumentStore.load(e.documentStore), n.pipeline = t.Pipeline.load(e.pipeline), n.index = {}; for (var i in e.index) n.index[i] = t.InvertedIndex.load(e.index[i]); return n }, t.Index.prototype.addField = function (e) { return this._fields.push(e), this.index[e] = new t.InvertedIndex, this }, t.Index.prototype.setRef = function (e) { return this._ref = e, this }, t.Index.prototype.saveDocument = function (e) { return this.documentStore = new t.DocumentStore(e), this }, t.Index.prototype.addDoc = function (e, n) { if (e) { var n = void 0 === n ? !0 : n, i = e[this._ref]; this.documentStore.addDoc(i, e), this._fields.forEach(function (n) { var o = this.pipeline.run(t.tokenizer(e[n])); this.documentStore.addFieldLength(i, n, o.length); var r = {}; o.forEach(function (e) { e in r ? r[e] += 1 : r[e] = 1 }, this); for (var s in r) { var u = r[s]; u = Math.sqrt(u), this.index[n].addToken(s, { ref: i, tf: u }) } }, this), n && this.eventEmitter.emit("add", e, this) } }, t.Index.prototype.removeDocByRef = function (e) { if (e && this.documentStore.isDocStored() !== !1 && this.documentStore.hasDoc(e)) { var t = this.documentStore.getDoc(e); this.removeDoc(t, !1) } }, t.Index.prototype.removeDoc = function (e, n) { if (e) { var n = void 0 === n ? !0 : n, i = e[this._ref]; this.documentStore.hasDoc(i) && (this.documentStore.removeDoc(i), this._fields.forEach(function (n) { var o = this.pipeline.run(t.tokenizer(e[n])); o.forEach(function (e) { this.index[n].removeToken(e, i) }, this) }, this), n && this.eventEmitter.emit("remove", e, this)) } }, t.Index.prototype.updateDoc = function (e, t) { var t = void 0 === t ? !0 : t; this.removeDocByRef(e[this._ref], !1), this.addDoc(e, !1), t && this.eventEmitter.emit("update", e, this) }, t.Index.prototype.idf = function (e, t) { var n = "@" + t + "/" + e; if (Object.prototype.hasOwnProperty.call(this._idfCache, n)) return this._idfCache[n]; var i = this.index[t].getDocFreq(e), o = 1 + Math.log(this.documentStore.length / (i + 1)); return this._idfCache[n] = o, o }, t.Index.prototype.getFields = function () { return this._fields.slice() }, t.Index.prototype.search = function (e, n) { if (!e) return []; e = "string" == typeof e ? { any: e } : JSON.parse(JSON.stringify(e)); var i = null; null != n && (i = JSON.stringify(n)); for (var o = new t.Configuration(i, this.getFields()).get(), r = {}, s = Object.keys(e), u = 0; u < s.length; u++) { var a = s[u]; r[a] = this.pipeline.run(t.tokenizer(e[a])) } var l = {}; for (var c in o) { var d = r[c] || r.any; if (d) { var f = this.fieldSearch(d, c, o), h = o[c].boost; for (var p in f) f[p] = f[p] * h; for (var p in f) p in l ? l[p] += f[p] : l[p] = f[p] } } var v, g = []; for (var p in l) v = { ref: p, score: l[p] }, this.documentStore.hasDoc(p) && (v.doc = this.documentStore.getDoc(p)), g.push(v); return g.sort(function (e, t) { return t.score - e.score }), g }, t.Index.prototype.fieldSearch = function (e, t, n) { var i = n[t].bool, o = n[t].expand, r = n[t].boost, s = null, u = {}; return 0 !== r ? (e.forEach(function (e) { var n = [e]; 1 == o && (n = this.index[t].expandToken(e)); var r = {}; n.forEach(function (n) { var o = this.index[t].getDocs(n), a = this.idf(n, t); if (s && "AND" == i) { var l = {}; for (var c in s) c in o && (l[c] = o[c]); o = l } n == e && this.fieldSearchStats(u, n, o); for (var c in o) { var d = this.index[t].getTermFrequency(n, c), f = this.documentStore.getFieldLength(c, t), h = 1; 0 != f && (h = 1 / Math.sqrt(f)); var p = 1; n != e && (p = .15 * (1 - (n.length - e.length) / n.length)); var v = d * a * h * p; c in r ? r[c] += v : r[c] = v } }, this), s = this.mergeScores(s, r, i) }, this), s = this.coordNorm(s, u, e.length)) : void 0 }, t.Index.prototype.mergeScores = function (e, t, n) { if (!e) return t; if ("AND" == n) { var i = {}; for (var o in t) o in e && (i[o] = e[o] + t[o]); return i } for (var o in t) o in e ? e[o] += t[o] : e[o] = t[o]; return e }, t.Index.prototype.fieldSearchStats = function (e, t, n) { for (var i in n) i in e ? e[i].push(t) : e[i] = [t] }, t.Index.prototype.coordNorm = function (e, t, n) { for (var i in e) if (i in t) { var o = t[i].length; e[i] = e[i] * o / n } return e }, t.Index.prototype.toJSON = function () { var e = {}; return this._fields.forEach(function (t) { e[t] = this.index[t].toJSON() }, this), { version: t.version, fields: this._fields, ref: this._ref, documentStore: this.documentStore.toJSON(), index: e, pipeline: this.pipeline.toJSON() } }, t.Index.prototype.use = function (e) { var t = Array.prototype.slice.call(arguments, 1); t.unshift(this), e.apply(this, t) }, t.DocumentStore = function (e) { this._save = null === e || void 0 === e ? !0 : e, this.docs = {}, this.docInfo = {}, this.length = 0 }, t.DocumentStore.load = function (e) { var t = new this; return t.length = e.length, t.docs = e.docs, t.docInfo = e.docInfo, t._save = e.save, t }, t.DocumentStore.prototype.isDocStored = function () { return this._save }, t.DocumentStore.prototype.addDoc = function (t, n) { this.hasDoc(t) || this.length++, this.docs[t] = this._save === !0 ? e(n) : null }, t.DocumentStore.prototype.getDoc = function (e) { return this.hasDoc(e) === !1 ? null : this.docs[e] }, t.DocumentStore.prototype.hasDoc = function (e) { return e in this.docs }, t.DocumentStore.prototype.removeDoc = function (e) { this.hasDoc(e) && (delete this.docs[e], delete this.docInfo[e], this.length--) }, t.DocumentStore.prototype.addFieldLength = function (e, t, n) { null !== e && void 0 !== e && 0 != this.hasDoc(e) && (this.docInfo[e] || (this.docInfo[e] = {}), this.docInfo[e][t] = n) }, t.DocumentStore.prototype.updateFieldLength = function (e, t, n) { null !== e && void 0 !== e && 0 != this.hasDoc(e) && this.addFieldLength(e, t, n) }, t.DocumentStore.prototype.getFieldLength = function (e, t) { return null === e || void 0 === e ? 0 : e in this.docs && t in this.docInfo[e] ? this.docInfo[e][t] : 0 }, t.DocumentStore.prototype.toJSON = function () { return { docs: this.docs, docInfo: this.docInfo, length: this.length, save: this._save } }, t.stemmer = function () { var e = { ational: "ate", tional: "tion", enci: "ence", anci: "ance", izer: "ize", bli: "ble", alli: "al", entli: "ent", eli: "e", ousli: "ous", ization: "ize", ation: "ate", ator: "ate", alism: "al", iveness: "ive", fulness: "ful", ousness: "ous", aliti: "al", iviti: "ive", biliti: "ble", logi: "log" }, t = { icate: "ic", ative: "", alize: "al", iciti: "ic", ical: "ic", ful: "", ness: "" }, n = "[^aeiou]", i = "[aeiouy]", o = n + "[^aeiouy]*", r = i + "[aeiou]*", s = "^(" + o + ")?" + r + o, u = "^(" + o + ")?" + r + o + "(" + r + ")?$", a = "^(" + o + ")?" + r + o + r + o, l = "^(" + o + ")?" + i, c = new RegExp(s), d = new RegExp(a), f = new RegExp(u), h = new RegExp(l), p = /^(.+?)(ss|i)es$/, v = /^(.+?)([^s])s$/, g = /^(.+?)eed$/, m = /^(.+?)(ed|ing)$/, y = /.$/, S = /(at|bl|iz)$/, x = new RegExp("([^aeiouylsz])\\1$"), w = new RegExp("^" + o + i + "[^aeiouwxy]$"), I = /^(.+?[^aeiou])y$/, b = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/, E = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/, D = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/, F = /^(.+?)(s|t)(ion)$/, _ = /^(.+?)e$/, P = /ll$/, k = new RegExp("^" + o + i + "[^aeiouwxy]$"), z = function (n) { var i, o, r, s, u, a, l; if (n.length < 3) return n; if (r = n.substr(0, 1), "y" == r && (n = r.toUpperCase() + n.substr(1)), s = p, u = v, s.test(n) ? n = n.replace(s, "$1$2") : u.test(n) && (n = n.replace(u, "$1$2")), s = g, u = m, s.test(n)) { var z = s.exec(n); s = c, s.test(z[1]) && (s = y, n = n.replace(s, "")) } else if (u.test(n)) { var z = u.exec(n); i = z[1], u = h, u.test(i) && (n = i, u = S, a = x, l = w, u.test(n) ? n += "e" : a.test(n) ? (s = y, n = n.replace(s, "")) : l.test(n) && (n += "e")) } if (s = I, s.test(n)) { var z = s.exec(n); i = z[1], n = i + "i" } if (s = b, s.test(n)) { var z = s.exec(n); i = z[1], o = z[2], s = c, s.test(i) && (n = i + e[o]) } if (s = E, s.test(n)) { var z = s.exec(n); i = z[1], o = z[2], s = c, s.test(i) && (n = i + t[o]) } if (s = D, u = F, s.test(n)) { var z = s.exec(n); i = z[1], s = d, s.test(i) && (n = i) } else if (u.test(n)) { var z = u.exec(n); i = z[1] + z[2], u = d, u.test(i) && (n = i) } if (s = _, s.test(n)) { var z = s.exec(n); i = z[1], s = d, u = f, a = k, (s.test(i) || u.test(i) && !a.test(i)) && (n = i) } return s = P, u = d, s.test(n) && u.test(n) && (s = y, n = n.replace(s, "")), "y" == r && (n = r.toLowerCase() + n.substr(1)), n }; return z }(), t.Pipeline.registerFunction(t.stemmer, "stemmer"), t.stopWordFilter = function (e) { return e && t.stopWordFilter.stopWords[e] !== !0 ? e : void 0 }, t.clearStopWords = function () { t.stopWordFilter.stopWords = {} }, t.addStopWords = function (e) { null != e && Array.isArray(e) !== !1 && e.forEach(function (e) { t.stopWordFilter.stopWords[e] = !0 }, this) }, t.resetStopWords = function () { t.stopWordFilter.stopWords = t.defaultStopWords }, t.defaultStopWords = { "": !0, a: !0, able: !0, about: !0, across: !0, after: !0, all: !0, almost: !0, also: !0, am: !0, among: !0, an: !0, and: !0, any: !0, are: !0, as: !0, at: !0, be: !0, because: !0, been: !0, but: !0, by: !0, can: !0, cannot: !0, could: !0, dear: !0, did: !0, "do": !0, does: !0, either: !0, "else": !0, ever: !0, every: !0, "for": !0, from: !0, get: !0, got: !0, had: !0, has: !0, have: !0, he: !0, her: !0, hers: !0, him: !0, his: !0, how: !0, however: !0, i: !0, "if": !0, "in": !0, into: !0, is: !0, it: !0, its: !0, just: !0, least: !0, let: !0, like: !0, likely: !0, may: !0, me: !0, might: !0, most: !0, must: !0, my: !0, neither: !0, no: !0, nor: !0, not: !0, of: !0, off: !0, often: !0, on: !0, only: !0, or: !0, other: !0, our: !0, own: !0, rather: !0, said: !0, say: !0, says: !0, she: !0, should: !0, since: !0, so: !0, some: !0, than: !0, that: !0, the: !0, their: !0, them: !0, then: !0, there: !0, these: !0, they: !0, "this": !0, tis: !0, to: !0, too: !0, twas: !0, us: !0, wants: !0, was: !0, we: !0, were: !0, what: !0, when: !0, where: !0, which: !0, "while": !0, who: !0, whom: !0, why: !0, will: !0, "with": !0, would: !0, yet: !0, you: !0, your: !0 }, t.stopWordFilter.stopWords = t.defaultStopWords, t.Pipeline.registerFunction(t.stopWordFilter, "stopWordFilter"), t.trimmer = function (e) { if (null === e || void 0 === e) throw new Error("token should not be undefined"); return e.replace(/^\W+/, "").replace(/\W+$/, "") }, t.Pipeline.registerFunction(t.trimmer, "trimmer"), t.InvertedIndex = function () { this.root = { docs: {}, df: 0 } }, t.InvertedIndex.load = function (e) { var t = new this; return t.root = e.root, t }, t.InvertedIndex.prototype.addToken = function (e, t, n) { for (var n = n || this.root, i = 0; i <= e.length - 1;) { var o = e[i]; o in n || (n[o] = { docs: {}, df: 0 }), i += 1, n = n[o] } var r = t.ref; n.docs[r] ? n.docs[r] = { tf: t.tf } : (n.docs[r] = { tf: t.tf }, n.df += 1) }, t.InvertedIndex.prototype.hasToken = function (e) { if (!e) return !1; for (var t = this.root, n = 0; n < e.length; n++) { if (!t[e[n]]) return !1; t = t[e[n]] } return !0 }, t.InvertedIndex.prototype.getNode = function (e) { if (!e) return null; for (var t = this.root, n = 0; n < e.length; n++) { if (!t[e[n]]) return null; t = t[e[n]] } return t }, t.InvertedIndex.prototype.getDocs = function (e) { var t = this.getNode(e); return null == t ? {} : t.docs }, t.InvertedIndex.prototype.getTermFrequency = function (e, t) { var n = this.getNode(e); return null == n ? 0 : t in n.docs ? n.docs[t].tf : 0 }, t.InvertedIndex.prototype.getDocFreq = function (e) { var t = this.getNode(e); return null == t ? 0 : t.df }, t.InvertedIndex.prototype.removeToken = function (e, t) { if (e) { var n = this.getNode(e); null != n && t in n.docs && (delete n.docs[t], n.df -= 1) } }, t.InvertedIndex.prototype.expandToken = function (e, t, n) { if (null == e || "" == e) return []; var t = t || []; if (void 0 == n && (n = this.getNode(e), null == n)) return t; n.df > 0 && t.push(e); for (var i in n) "docs" !== i && "df" !== i && this.expandToken(e + i, t, n[i]); return t }, t.InvertedIndex.prototype.toJSON = function () { return { root: this.root } }, t.Configuration = function (e, n) { var e = e || ""; if (void 0 == n || null == n) throw new Error("fields should not be null"); this.config = {}; var i; try { i = JSON.parse(e), this.buildUserConfig(i, n) } catch (o) { t.utils.warn("user configuration parse failed, will use default configuration"), this.buildDefaultConfig(n) } }, t.Configuration.prototype.buildDefaultConfig = function (e) { this.reset(), e.forEach(function (e) { this.config[e] = { boost: 1, bool: "OR", expand: !1 } }, this) }, t.Configuration.prototype.buildUserConfig = function (e, n) { var i = "OR", o = !1; if (this.reset(), "bool" in e && (i = e.bool || i), "expand" in e && (o = e.expand || o), "fields" in e) for (var r in e.fields) if (n.indexOf(r) > -1) { var s = e.fields[r], u = o; void 0 != s.expand && (u = s.expand), this.config[r] = { boost: s.boost || 0 === s.boost ? s.boost : 1, bool: s.bool || i, expand: u } } else t.utils.warn("field name in user configuration not found in index instance fields"); else this.addAllFields2UserConfig(i, o, n) }, t.Configuration.prototype.addAllFields2UserConfig = function (e, t, n) { n.forEach(function (n) { this.config[n] = { boost: 1, bool: e, expand: t } }, this) }, t.Configuration.prototype.get = function () { return this.config }, t.Configuration.prototype.reset = function () { this.config = {} }, lunr.SortedSet = function () { this.length = 0, this.elements = [] }, lunr.SortedSet.load = function (e) { var t = new this; return t.elements = e, t.length = e.length, t }, lunr.SortedSet.prototype.add = function () { var e, t; for (e = 0; e < arguments.length; e++)t = arguments[e], ~this.indexOf(t) || this.elements.splice(this.locationFor(t), 0, t); this.length = this.elements.length }, lunr.SortedSet.prototype.toArray = function () { return this.elements.slice() }, lunr.SortedSet.prototype.map = function (e, t) { return this.elements.map(e, t) }, lunr.SortedSet.prototype.forEach = function (e, t) { return this.elements.forEach(e, t) }, lunr.SortedSet.prototype.indexOf = function (e) { for (var t = 0, n = this.elements.length, i = n - t, o = t + Math.floor(i / 2), r = this.elements[o]; i > 1;) { if (r === e) return o; e > r && (t = o), r > e && (n = o), i = n - t, o = t + Math.floor(i / 2), r = this.elements[o] } return r === e ? o : -1 }, lunr.SortedSet.prototype.locationFor = function (e) { for (var t = 0, n = this.elements.length, i = n - t, o = t + Math.floor(i / 2), r = this.elements[o]; i > 1;)e > r && (t = o), r > e && (n = o), i = n - t, o = t + Math.floor(i / 2), r = this.elements[o]; return r > e ? o : e > r ? o + 1 : void 0 }, lunr.SortedSet.prototype.intersect = function (e) { for (var t = new lunr.SortedSet, n = 0, i = 0, o = this.length, r = e.length, s = this.elements, u = e.elements; ;) { if (n > o - 1 || i > r - 1) break; s[n] !== u[i] ? s[n] < u[i] ? n++ : s[n] > u[i] && i++ : (t.add(s[n]), n++, i++) } return t }, lunr.SortedSet.prototype.clone = function () { var e = new lunr.SortedSet; return e.elements = this.toArray(), e.length = e.elements.length, e }, lunr.SortedSet.prototype.union = function (e) { var t, n, i; this.length >= e.length ? (t = this, n = e) : (t = e, n = this), i = t.clone(); for (var o = 0, r = n.toArray(); o < r.length; o++)i.add(r[o]); return i }, lunr.SortedSet.prototype.toJSON = function () { return this.toArray() }, function (e, t) { "function" == typeof define && define.amd ? define(t) : "object" == typeof exports ? module.exports = t() : e.elasticlunr = t() }(this, function () { return t }) }();
    /** pdoc search index */const docs = [{ "fullname": "main", "modulename": "main", "kind": "module", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator", "modulename": "main", "qualname": "TaxCalculator", "kind": "class", "doc": "<p>A tax calculation application with PDF viewing capabilities.</p>\n\n<p>This class provides a Tkinter-based GUI for calculating employment income deductions\nand viewing PDF documents. It supports two salary input modes:\nsingle monthly salary and monthly variations.</p>\n\n<p>Attributes:\n    root                          (tk.Tk): The main application window.\n    salary_mode            (tk.StringVar): Tracks the current salary input mode.\n    monthly_salaries (List[tk.StringVar]): List of monthly salary input variables.\n    current_pdf (Optional[fitz.Document]): Currently loaded PDF document.\n    current_page                    (int): Current page number in the PDF viewer.\n    pdf_zoom                      (float): Current zoom level for PDF viewing.</p>\n" }, { "fullname": "main.TaxCalculator.__init__", "modulename": "main", "qualname": "TaxCalculator.__init__", "kind": "function", "doc": "<p>Initialize the tax calculator application.</p>\n\n<p>Args:\n    root (TkinterDnD.Tk): The main Tkinter window for the application.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">root</span><span class=\"p\">:</span> <span class=\"n\">tkinter</span><span class=\"o\">.</span><span class=\"n\">Tk</span></span>)</span>" }, { "fullname": "main.TaxCalculator.root", "modulename": "main", "qualname": "TaxCalculator.root", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.main_frame", "modulename": "main", "qualname": "TaxCalculator.main_frame", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.salary_mode", "modulename": "main", "qualname": "TaxCalculator.salary_mode", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.monthly_salaries", "modulename": "main", "qualname": "TaxCalculator.monthly_salaries", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.current_pdf", "modulename": "main", "qualname": "TaxCalculator.current_pdf", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.current_page", "modulename": "main", "qualname": "TaxCalculator.current_page", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.pdf_zoom", "modulename": "main", "qualname": "TaxCalculator.pdf_zoom", "kind": "variable", "doc": "<p></p>\n" }, { "fullname": "main.TaxCalculator.create_salary_mode_selection", "modulename": "main", "qualname": "TaxCalculator.create_salary_mode_selection", "kind": "function", "doc": "<p>Create radio buttons for selecting salary input mode.</p>\n\n<p>Allows switching between single monthly salary and monthly detailed salary inputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.create_input_fields", "modulename": "main", "qualname": "TaxCalculator.create_input_fields", "kind": "function", "doc": "<p>Create and arrange input fields for salary and bonus information.</p>\n\n<p>Sets up entry fields for:\n    - Single monthly salary or monthly salary varioations.\n    - First bonus amount\n    - Second bonus amount</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.toggle_salary_mode_input", "modulename": "main", "qualname": "TaxCalculator.toggle_salary_mode_input", "kind": "function", "doc": "<p>Toggle between salary input modes.</p>\n\n<p>Switches the visibility of the input frame between <code>single monthly salary</code> and\n<code>monthly detailed salary</code> modes based on the selected radio button.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.create_buttons", "modulename": "main", "qualname": "TaxCalculator.create_buttons", "kind": "function", "doc": "<p>Create and place calculation and clear buttons.</p>\n\n<p>Buttons are created using predefined constant texts and\nbound to corresponding command methods.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.create_result_labels", "modulename": "main", "qualname": "TaxCalculator.create_result_labels", "kind": "function", "doc": "<p>Create and place labels for yearly salary and income amount results.</p>\n\n<p>Adds a separator and initializes labels to display calculation results.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.create_pdf_viewer", "modulename": "main", "qualname": "TaxCalculator.create_pdf_viewer", "kind": "function", "doc": "<p>Create PDF viewer frame and control elements.</p>\n\n<p>Sets up UI elements for PDF file selection, page navigation, and zoom functionality.\nEnables drag and drop capability.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.open_pdf_file", "modulename": "main", "qualname": "TaxCalculator.open_pdf_file", "kind": "function", "doc": "<p>Open file dialog to select and load a PDF file.</p>\n\n<p>Launches a file selection dialog and calls load_pdf method\nwhen a PDF file is selected by user.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.handle_drop", "modulename": "main", "qualname": "TaxCalculator.handle_drop", "kind": "function", "doc": "<p>Handle PDF file drag and drop event.</p>\n\n<p>Verified that the dropped file is a PDF file and loads the first PDF file.\nDisplays an error message if non-PDF files are dropped.</p>\n\n<p>Args:\n    event (tk.Event): Drag and drop event</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">tkinter</span><span class=\"o\">.</span><span class=\"n\">Event</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.load_pdf", "modulename": "main", "qualname": "TaxCalculator.load_pdf", "kind": "function", "doc": "<p>Load and display a PDF file.</p>\n\n<p>Args:\n    filename (str): Path to the PDF file to be loaded.</p>\n\n<p>Raises:\n    PermissionError: If there are permission issues accessing the file.\n    FileNotFoundError: If the specified file does not exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.display_page", "modulename": "main", "qualname": "TaxCalculator.display_page", "kind": "function", "doc": "<p>Display the current PDF page on the canvas.</p>\n\n<p>Renders the page according to the current zoom level and places it on the canvas.\nDoes nothing if no PDF is loaded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.prev_page", "modulename": "main", "qualname": "TaxCalculator.prev_page", "kind": "function", "doc": "<p>Navigate to the previous page in the PDF viewer.</p>\n\n<p>Moves back one page if not on the first page and updates corresponding button states.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.next_page", "modulename": "main", "qualname": "TaxCalculator.next_page", "kind": "function", "doc": "<p>Navigate to the next page in the PDF viewer.</p>\n\n<p>Moves forward one page if not one the last page and updates corresponding button states.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.zoom_in", "modulename": "main", "qualname": "TaxCalculator.zoom_in", "kind": "function", "doc": "<p>Zoom in one th PDF page.</p>\n\n<p>Enlarges the page up to the configured maximum zoom level and redraws the page.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.zoom_out", "modulename": "main", "qualname": "TaxCalculator.zoom_out", "kind": "function", "doc": "<p>Zoom out of the PDF page.</p>\n\n<p>Reduces the page down to the configured minimum zoom level and redraws the page.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.update_zoom_display", "modulename": "main", "qualname": "TaxCalculator.update_zoom_display", "kind": "function", "doc": "<p>Update the zoom level display label.</p>\n\n<p>Updates and displays the zoom percentage in the label.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.format_currency", "modulename": "main", "qualname": "TaxCalculator.format_currency", "kind": "function", "doc": "<p>Format the given amount as currency with thousands separator.</p>\n\n<p>Args:\n    amount (Union[int, float]): The monetary amount to format.</p>\n\n<p>Returns:\n    str: Formatted currency string without currency symbol.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">amount</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.validate_entry", "modulename": "main", "qualname": "TaxCalculator.validate_entry", "kind": "function", "doc": "<p>Validate user input to allow only numeric characters, commas, and spaces.</p>\n\n<p>Args:\n    text (str): input text to validatetest (str): The input text to validate.</p>\n\n<p>Returns:\n    bool: True if input is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.calculate_income", "modulename": "main", "qualname": "TaxCalculator.calculate_income", "kind": "function", "doc": "<p>Calculate yearly income and employment income deduction.</p>\n\n<p>Supports both single monthly salary and monthly variations.\nUses predefined income rules from <code>config.py</code>.</p>\n\n<p>Args:\n    monthly_salaries (Union[int, List[int]]): Monthly salary amount or list of monthly salaries.\n    bonus1                   (int, optional): First bonus amount. Defaults to 0.\n    bonus2                   (int, optional): Second bonus amount. Defaults to 0.</p>\n\n<p>Returns:\n    Tuple[int, int]: A tuple containing (yearly salary, income after deduction).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">monthly_salaries</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">bonus1</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">bonus2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.calculate", "modulename": "main", "qualname": "TaxCalculator.calculate", "kind": "function", "doc": "<p>Calculate yearly salary and income amount from salary and bonuses.</p>\n\n<p>Cleans up input values and performs calculation based on the selected input mode.\nDisplays results in labels and shows an error message for invalid inputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.TaxCalculator.clear", "modulename": "main", "qualname": "TaxCalculator.clear", "kind": "function", "doc": "<p>Clear all input fields and result labels.</p>\n\n<p>Resets monthly salary, bonus input fields, and result labels to empty state.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }, { "fullname": "main.main", "modulename": "main", "qualname": "main", "kind": "function", "doc": "<p>Main function to initialize and run the tax calculator application.</p>\n\n<p>Creates the main Tkinter window and starts the application event loop.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def" }];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: { boost: 4 },
            fullname: { boost: 2 },
            annotation: { boost: 2 },
            default_value: { boost: 2 },
            signature: { boost: 2 },
            bases: { boost: 2 },
            doc: { boost: 1 },
        },
        expand: true
    });
})();
